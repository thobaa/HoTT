(* -*- mode: coq; mode: visual-line -*- *)
Require Import HoTT.Basics HoTT.Types.
Require Import Extensions.
Require Import Modality Accessible Lex Nullification.

Local Open Scope path_scope.
Local Open Scope equiv_scope.

(** * Topological localizations *)

(** A topological localization -- or, as we will say, a topological nullification -- is a nullification at a family of hprops, or more generally an accessible modality whose generators of accessibility are all hprops.  This is not quite the same as Lurie's definition: in Higher Topos Theory, a topological localization is an accessible *left exact* localization at a pullback-stable class generated by a set of monomorphisms.  "Pullback-stable class generated by" is roughly incorporated into our internal notion of accessibility, so the main new difference here is that when the generation is internal in this way, the localization at a family of hprops is *automatically* left exact. *)

Module Type Topological_Modalities
       (Os : Modalities) (Acc : Accessible_Modalities Os).

  Import Os Acc.

  Parameter ua : Modality -> Univalence.

  Parameter ishprop_acc_gen
  : forall (O : Modality) i, IsHProp (acc_gen O i).
  Check ishprop_acc_gen@{u a}.

End Topological_Modalities.

(** ** Topological modalities are lex *)

(** We prove left-exactness by proving that the universe of modal types is modal.  Of course, this require univalence; hence why we have included it in the definition of [Topological_Modalities] above. *)

Module Lex_Topological_Modalities
       (Os : Modalities) (Acc : Accessible_Modalities Os)
       (Top : Topological_Modalities Os Acc).

  Module InOT <: InO_Type Os.

    Export Os.
    Module Export Os_Theory := Modalities_Theory Os.
    Module Export Acc_Theory := Accessible_Modalities_Theory Os Acc.

    Definition inO_typeO (O : Modality@{u a})
    : let enforce_le := idmap : Type@{a} -> Type@{i} in
      In@{u a j} O (Type_@{u a j i} O).
    Proof.
      refine (snd (inO_iff_isnull O _) _); intros i.
      pose proof (Top.ua O).
      pose proof (Top.ishprop_acc_gen O i).
      refine (equiv_inverse (equiv_ooextendable_isequiv _ _) _).
      refine (isequiv_adjointify _ _ _ _); simpl.
      - intros B _.
        refine ((forall a, B a) ; _).
        exact _.
      - intros B.
        apply path_arrow; intros a.
        apply path_TypeO, path_universe_uncurried.
        unfold composeD; simpl.
        refine (equiv_adjointify _ _ _ _).
        + intros f. exact (f a).
        + intros b a'. exact (transport B (path_ishprop a a') b).
        + intros b.
          refine (transport2 B (path_contr _ 1) b).
        + intros f. apply path_forall; intros a'.
          exact (apD f _).
      - intros B.
        apply path_arrow; intros [].
        apply path_TypeO, path_universe_uncurried.
        unfold composeD; simpl.
        pose (e := isequiv_ooextendable _ _
                                        (fst (inO_iff_isnull O (B tt)) _ i)).
        unfold composeD in e; simpl in e.
        refine (equiv_compose' _ (equiv_inverse (BuildEquiv _ _ _ e))).
        exact (equiv_contr_forall _).
    Defined.

  End InOT.

  Module Lex <: Lex_Modalities Os
    := Lex_InO_Type Os InOT.

End Lex_Topological_Modalities.

(** ** Topological nullifications *)

(** We define the topological nullifications to be the restrictions of nullifications to families of hprops, with the additional assumption of univalence.  Therefore, every topological nullification is topological, and hence lex. *)

Record TopologicalNullification_Modality
  := TNul { uaTNul : Univalence ;
            unTNul : NullGenerators ;
            ishprop_unTNul : forall i, IsHProp (unTNul i)
          }.

(** We define the module as a restriction *)

Module Topological_Restriction_Data
<: Modalities_Restriction_Data Nullification_Modalities.

  Definition New_Modality : Type2@{u a}
    := TopologicalNullification_Modality@{a}.

  Definition Modalities_restriction
  : New_Modality -> Nullification_Modality
  := fun O => Nul (unTNul O).

End Topological_Restriction_Data.

Module TopologicalNullification_Modalities <: Modalities
  := Modalities_Restriction Nullification_Modalities Topological_Restriction_Data.

Module Import TNulM := Modalities_Theory TopologicalNullification_Modalities.
Export TNulM.Coercions.
Export TNulM.RSU.Coercions.

Coercion TopologicalNullification_Modality_to_Modality := idmap
  : TopologicalNullification_Modality -> Modality.

(** Now we show it is accessible *)

Module Accessible_Restriction_TopologicalNullification
  := Accessible_Restriction_Modalities
       Nullification_Modalities
       Accessible_Nullification
       Topological_Restriction_Data.
Module Import Accessible_TopologicalNullification
  <: Accessible_Modalities TopologicalNullification_Modalities
  := Accessible_Restriction_TopologicalNullification.Accessible_New.

(** Now we show it is topological *)

Module Import Topological_TopologicalNullification_Modalities
<: Topological_Modalities
     TopologicalNullification_Modalities
     Accessible_TopologicalNullification.

  Definition ua : Modality -> Univalence := uaTNul.

  Definition ishprop_acc_gen
  : forall (O : Modality@{u a}) i, IsHProp (acc_gen O i)
    := fun O i => ishprop_unTNul O i.

End Topological_TopologicalNullification_Modalities.

(** And therefore lex *)

Module Lex_Topological_TopologicalNullification_Modalities
  := Lex_Topological_Modalities
       TopologicalNullification_Modalities
       Accessible_TopologicalNullification
       Topological_TopologicalNullification_Modalities.
Module Import Lex_TopologicalNullification_Modalities
<: Lex_Modalities TopologicalNullification_Modalities
  := Lex_Topological_TopologicalNullification_Modalities.Lex.

(** ** Univalence as a module type *)

(** It's occasionally useful to have a module type witnessing univalence. *)

Module Type UnivalenceM.
  Parameter ua : Univalence.
End UnivalenceM.
